<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Span Visualizer (2D)</title>
  <style>
    body { font-family: system-ui, Arial; margin: 0; display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    .panel { padding: 16px; border-right: 1px solid #ddd; overflow:auto; }
    .row { margin: 10px 0; }
    label { display: block; font-size: 13px; color:#333; margin-bottom: 6px; }
    input[type="range"] { width: 100%; }
    input[type="number"] { padding:6px 8px; border:1px solid #ccc; border-radius:10px; }
    .small { font-size: 12px; color:#666; }
    canvas { width: 100%; height: 100%; display:block; background:#fafafa; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ccc; border-radius:999px; font-size:12px; margin-right:6px;}
    .hint { background:#fff; border:1px solid #eee; padding:10px; border-radius:12px; }
    button { padding:8px 10px; border:1px solid #ccc; background:#fff; border-radius:10px; cursor:pointer; }
    button:active { transform: translateY(1px); }
    h2 { margin:0 0 6px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .vecRow { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="panel">
    <h2>Span Visualizer</h2>
    <div class="small">
      Set/drag two vectors <b>u</b> and <b>v</b>. Use sliders for scalars <b>a</b>, <b>b</b>. We draw <b>a·u + b·v</b>.
    </div>

    <div class="row">
      <label>a (scalar for u): <span id="aVal" class="pill"></span></label>
      <input id="a" type="range" min="-5" max="5" step="0.1" value="1" />
    </div>

    <div class="row">
      <label>b (scalar for v): <span id="bVal" class="pill"></span></label>
      <input id="b" type="range" min="-5" max="5" step="0.1" value="1" />
    </div>

    <div class="row hint">
      <div style="margin-bottom:8px;"><b>Set the two basis vectors</b></div>

      <div class="vecRow">
        <span class="pill"><b>u</b> = (</span>
        <input id="ux" type="number" step="0.1" />
        <span>,</span>
        <input id="uy" type="number" step="0.1" />
        <span>)</span>
      </div>

      <div class="vecRow" style="margin-top:8px;">
        <span class="pill"><b>v</b> = (</span>
        <input id="vx" type="number" step="0.1" />
        <span>,</span>
        <input id="vy" type="number" step="0.1" />
        <span>)</span>
      </div>

      <div style="margin-top:10px;">
        <label style="display:flex; gap:8px; align-items:center; margin:0;">
          <input id="showStdDecomp" type="checkbox" />
          Show u and v as (x-part)î + (y-part)ĵ
        </label>
      </div>

      <div style="margin-top:6px;">
        <label style="display:flex; gap:8px; align-items:center; margin:0;">
          <input id="showStdBasis" type="checkbox" checked />
          Show standard basis î=(1,0), ĵ=(0,1)
        </label>
      </div>
    </div>

    <div class="row hint">
      <div><b>Status:</b> <span id="status"></span></div>
    </div>

    <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
      <button id="reset">Reset u,v</button>
      <button id="random">Random u,v</button>
    </div>

    <div class="small">
      <p><b>How to read span (in 2D):</b></p>
      <ul>
        <li>If u and v are <b>dependent</b> → span is a <b>line</b>.</li>
        <li>If u and v are <b>independent</b> → span is <b>all of R²</b>.</li>
      </ul>
    </div>
  </div>

  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  let scale = 60;
  function toScreen(p) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: rect.width/2 + p.x * scale,
      y: rect.height/2 - p.y * scale
    };
  }
  function toWorld(s) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (s.x - rect.width/2)/scale,
      y: -(s.y - rect.height/2)/scale
    };
  }

  let u = {x: 2, y: 1};
  let v = {x: -1, y: 2};

  const aSlider = document.getElementById("a");
  const bSlider = document.getElementById("b");
  const aVal = document.getElementById("aVal");
  const bVal = document.getElementById("bVal");
  const status = document.getElementById("status");

  const uxIn = document.getElementById("ux");
  const uyIn = document.getElementById("uy");
  const vxIn = document.getElementById("vx");
  const vyIn = document.getElementById("vy");
  const showStdDecomp = document.getElementById("showStdDecomp");
  const showStdBasis = document.getElementById("showStdBasis");

  function getA(){ return parseFloat(aSlider.value); }
  function getB(){ return parseFloat(bSlider.value); }

  function det2(u,v){ return u.x*v.y - u.y*v.x; }

  function syncInputsFromVectors(){
    uxIn.value = u.x.toFixed(2);
    uyIn.value = u.y.toFixed(2);
    vxIn.value = v.x.toFixed(2);
    vyIn.value = v.y.toFixed(2);
  }

  function syncVectorsFromInputs(){
    const nx = parseFloat(uxIn.value), ny = parseFloat(uyIn.value);
    const mx = parseFloat(vxIn.value), my = parseFloat(vyIn.value);
    if (!Number.isNaN(nx) && !Number.isNaN(ny)) u = {x:nx, y:ny};
    if (!Number.isNaN(mx) && !Number.isNaN(my)) v = {x:mx, y:my};
    draw();
  }

  [uxIn, uyIn, vxIn, vyIn].forEach(inp => inp.addEventListener("input", syncVectorsFromInputs));
  showStdDecomp.addEventListener("change", draw);
  showStdBasis.addEventListener("change", draw);

  function line(x1,y1,x2,y2, w=2) {
    ctx.lineWidth = w;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }

  function arrow(from, vec, color, label) {
    const p0 = toScreen(from);
    const p1 = toScreen({x: from.x + vec.x, y: from.y + vec.y});

    ctx.strokeStyle = color;
    ctx.fillStyle = color;

    line(p0.x,p0.y,p1.x,p1.y,2);

    const dx = p1.x - p0.x, dy = p1.y - p0.y;
    const L = Math.hypot(dx,dy) || 1;
    const ux = dx/L, uy = dy/L;
    const head = 12;
    const left = { x: p1.x - head*ux - 6*uy, y: p1.y - head*uy + 6*ux };
    const right= { x: p1.x - head*ux + 6*uy, y: p1.y - head*uy - 6*ux };

    ctx.beginPath();
    ctx.moveTo(p1.x,p1.y);
    ctx.lineTo(left.x,left.y);
    ctx.lineTo(right.x,right.y);
    ctx.closePath();
    ctx.fill();

    if (label) {
      ctx.font = "14px system-ui";
      ctx.fillText(label, p1.x + 8, p1.y - 8);
    }
  }

  function drawAxes() {
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);

    ctx.strokeStyle = "#eee";
    ctx.lineWidth = 1;
    const step = scale;
    for (let x = rect.width/2 % step; x < rect.width; x += step) line(x,0,x,rect.height,1);
    for (let y = rect.height/2 % step; y < rect.height; y += step) line(0,y,rect.width,y,1);

    ctx.strokeStyle = "#bbb";
    line(0, rect.height/2, rect.width, rect.height/2, 2);
    line(rect.width/2, 0, rect.width/2, rect.height, 2);
  }

  function drawStdBasis() {
    arrow({x:0,y:0}, {x:1,y:0}, "rgba(0,0,0,0.35)", "î");
    arrow({x:0,y:0}, {x:0,y:1}, "rgba(0,0,0,0.35)", "ĵ");
  }

  function drawDecomposition(vec, label) {
    const xPart = {x: vec.x, y: 0};
    const yPart = {x: 0, y: vec.y};

    arrow({x:0,y:0}, xPart, "rgba(0,0,0,0.15)", `${label}_x î`);
    arrow({x:xPart.x,y:xPart.y}, yPart, "rgba(0,0,0,0.15)", `${label}_y ĵ`);

    const corner = toScreen({x:xPart.x,y:xPart.y});
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.arc(corner.x, corner.y, 3, 0, Math.PI*2);
    ctx.fill();
  }

  function drawSpanPreview() {
    const D = det2(u,v);
    const eps = 1e-8;

    if (Math.abs(D) < eps) {
      const base = (Math.hypot(u.x,u.y) > 1e-6) ? u : v;
      ctx.strokeStyle = "rgba(0,0,0,0.15)";
      const t = 100;
      const pA = toScreen({x: -t*base.x, y: -t*base.y});
      const pB = toScreen({x:  t*base.x, y:  t*base.y});
      line(pA.x,pA.y,pB.x,pB.y,3);
    } else {
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      for (let i=-5;i<=5;i++){
        for (let j=-5;j<=5;j++){
          const p = {x: i*u.x + j*v.x, y: i*u.y + j*v.y};
          const s = toScreen(p);
          ctx.beginPath();
          ctx.arc(s.x,s.y,2,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }

  function drawHandles() {
    const hu = toScreen(u);
    const hv = toScreen(v);

    ctx.fillStyle = "#e11";
    ctx.beginPath(); ctx.arc(hu.x, hu.y, 8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#14b";
    ctx.beginPath(); ctx.arc(hv.x, hv.y, 8, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "#333";
    ctx.font = "12px system-ui";
    ctx.fillText("drag u", hu.x + 10, hu.y + 4);
    ctx.fillText("drag v", hv.x + 10, hv.y + 4);
  }

  function updateStatus() {
    const D = det2(u,v);
    const eps = 1e-8;
    if (Math.abs(D) < eps) {
      status.textContent = "u and v are linearly dependent → span is a LINE.";
    } else {
      status.textContent = "u and v are linearly independent → span is ALL of R².";
    }
  }

  function draw() {
    aVal.textContent = getA().toFixed(1);
    bVal.textContent = getB().toFixed(1);

    drawAxes();
    drawSpanPreview();

    if (showStdBasis.checked) drawStdBasis();
    if (showStdDecomp.checked) {
      drawDecomposition(u, "u");
      drawDecomposition(v, "v");
    }

    arrow({x:0,y:0}, u, "#e11", "u");
    arrow({x:0,y:0}, v, "#14b", "v");

    const a = getA(), b = getB();
    const combo = {x: a*u.x + b*v.x, y: a*u.y + b*v.y};

    arrow({x:0,y:0}, {x:a*u.x,y:a*u.y}, "rgba(225,17,17,0.35)", "a·u");
    arrow({x:a*u.x,y:a*u.y}, {x:b*v.x,y:b*v.y}, "rgba(20,68,187,0.35)", "b·v");

    arrow({x:0,y:0}, combo, "#111", "a·u + b·v");

    drawHandles();
    updateStatus();
  }

  aSlider.addEventListener("input", draw);
  bSlider.addEventListener("input", draw);

  let dragging = null;
  function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }

  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouse = {x: e.clientX - rect.left, y: e.clientY - rect.top};
    const hu = toScreen(u);
    const hv = toScreen(v);
    if (dist(mouse, hu) < 12) dragging = "u";
    else if (dist(mouse, hv) < 12) dragging = "v";
  });
  window.addEventListener("mouseup", () => dragging = null);
  window.addEventListener("mousemove", (e) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const mouse = {x: e.clientX - rect.left, y: e.clientY - rect.top};
    const w = toWorld(mouse);
    if (dragging === "u") u = w;
    if (dragging === "v") v = w;
    syncInputsFromVectors();
    draw();
  });

  document.getElementById("reset").addEventListener("click", () => {
    u = {x: 2, y: 1};
    v = {x: -1, y: 2};
    aSlider.value = 1;
    bSlider.value = 1;
    syncInputsFromVectors();
    draw();
  });

  document.getElementById("random").addEventListener("click", () => {
    const r = () => Math.round((Math.random()*6 - 3)*10)/10;
    u = {x: r(), y: r()};
    v = {x: r(), y: r()};
    syncInputsFromVectors();
    draw();
  });

  syncInputsFromVectors();
  resize();
})();
</script>
</body>
</html>
